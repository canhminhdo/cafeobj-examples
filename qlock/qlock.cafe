-- 
-- Qlock: a mutual exclustion protocol
-- based on an atomic queue and an abstract
-- version of the Dijkstra's binary semaphore
-- 
-- Loop: Remainder Section
--  rs: enq(queue,i);
--  ws: repeat until top(queue) = i;
--    Critical Section
--  cs: deq(queue);
--
-- Note that queue is an atomic queue,
-- where enq, top and deq are atomic, and
-- queue is used in neither Remainder Section
-- nor Critical Section.
-- 

mod! LABEL {
    [Label]
    ops rs ws cs : -> Label .
    eq (rs = ws) = false .
    eq (rs = cs) = false .
    eq (ws = cs) = false .
}

mod! PID {
    [Pid]
}

mod! QUEUE(E :: TRIV) {
    [EQueue NeQueue < Queue]
    [Elt.E < Elt&Err]

    op err : -> Elt&Err {constr}
    op emp : -> EQueue {constr}
    op __ : Elt.E Queue -> NeQueue {constr}
    op enq : Queue Elt.E -> NeQueue
    op deq : Queue -> Queue
    op top : Queue -> Elt&Err
    op _\in_ : Elt.E Queue -> Bool
    op del : Queue Elt.E -> Queue

    var Q : Queue .
    vars X Y : Elt.E 

    eq enq(emp, X) = X emp .
    eq enq(Y Q, X) = Y enq(Q, X) .
    eq deq(emp) = emp .
    eq deq(X Q) = Q .
    eq top(emp) = err .
    eq top(X Q) = X .
    eq X \in emp = false .
    eq X \in (Y Q) = (if X = Y then true else X \in Q fi) .
    -- delete X that firts appeared in a queue
    eq del(emp, X) = emp .
    eq del(Y Q, X) = (if X = Y then Q else Y del(Q, X) fi) .
    -- lemmas
    ceq (top(enq(Q, Y)) = X) = true if top(Q) = X .
}

view TRIV2PID from TRIV to PID {
    sort Elt -> Pid
}

mod* QLOCK {
    pr(LABEL + PID)
    pr(QUEUE(E <= TRIV2PID))
    [Sys]
    -- initial states
    op init : -> Sys {constr}
    -- transitions
    op want : Sys Pid -> Sys {constr}
    op try : Sys Pid -> Sys {constr}
    op exit : Sys Pid -> Sys {constr}
    -- observation functions
    op pc : Sys Pid -> Label
    op queue : Sys -> Queue

    var S : Sys .
    vars I J : Pid .
    var Q : Queue .

    -- for initial states
    eq pc(init, I) = rs .
    eq queue(init) = emp .
    -- for want
    op c-want : Sys Pid -> Bool
    eq c-want(S, I) = (pc(S, I) = rs) .
    -- 
    ceq pc(want(S, I), J) = (if I = J then ws else pc(S, J) fi) if c-want(S, I) .
    ceq queue(want(S, I)) = enq(queue(S), I) if c-want(S, I) .
    ceq want(S, I) = S if not c-want(S, I) .
    -- for try
    op c-try : Sys Pid -> Bool 
    eq c-try(S, I) = (pc(S, I) = ws and top(queue(S)) = I) .
    -- 
    ceq pc(try(S, I), J) = (if I = J then cs else pc(S, J) fi) if c-try(S, I) .
    eq queue(try(S, I)) = queue(S) .
    ceq try(S, I) = S if not c-try(S, I) .
    -- for exit
    op c-exit : Sys Pid -> Bool
    eq c-exit(S, I) = (pc(S, I) = cs) .
    -- 
    ceq pc(exit(S, I), J) = (if I = J then rs else pc(S, J) fi) if c-exit(S, I) .
    ceq queue(exit(S, I)) = deq(queue(S)) if c-exit(S, I) .
    ceq exit(S, I) = S if not c-exit(S, I) .
    -- 
    -- Properties
    -- 
    op mutex : Sys Pid Pid -> Bool
    eq mutex(S, I, J) = ((pc(S, I) = cs and pc(S, J) = cs) implies (I = J)) .

    op inv1 : Sys Pid -> Bool
    eq inv1(S, I) = (pc(S, I) = cs implies top(queue(S)) = I) .
}