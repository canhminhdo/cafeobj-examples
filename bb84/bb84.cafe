mod! PRIN principal-sort Prin {
    [Prin]
    op intruder : -> Prin {constr}
}

mod! RAND principal-sort Rand {
    [Rand]
}

mod! KEY principal-sort Key {
    [Key]
    ops 0 1 : -> Key {constr}
    eq (0 = 1) = false .
}

mod! BASIS principal-sort Basis {
    [Basis]
    ops + x : -> Basis {constr}
    eq (+ = x) = false .
}

mod! QUBIT {
    pr(KEY + BASIS)
    [Qubit]
    op qubit : Key Basis -> Qubit {constr}
    op k : Qubit -> Key
    op b : Qubit -> Basis
    op measure : Qubit Basis -> Key .
    vars K K' : Key
    vars B B' : Basis
    eq (qubit(K, B) = qubit(K', B')) = (K = K' and B = B') .
    eq k(qubit(K,B)) = K .
    eq b(qubit(K,B)) = B .
}

mod! ACK principal-sort Ack {
    [Ack]
    ops ok notOk : -> Ack {constr}
    eq (ok = notOk) = false .
}

mod! TUPLE3(X :: TRIV, Y :: TRIV, Z :: TRIV) {
    [Tuple3]
    op (_,_,_) : Elt.X Elt.Y Elt.Z -> Tuple3 {constr}
    op 1* : Tuple3 -> Elt.X
    op 2* : Tuple3 -> Elt.Y
    op 3* : Tuple3 -> Elt.Z
    var X : Elt.X
    var Y : Elt.Y
    var Z : Elt.Z
    eq 1*((X,Y,Z)) = X .
    eq 2*((X,Y,Z)) = Y .
    eq 3*((X,Y,Z)) = Z .
}

mod! KEY-KNOWLEDGE principal-sort KeyKL {
    pr(TUPLE3(PRIN,RAND,KEY) * {
        sort Tuple3 -> KeyKL,
        op 1* -> prin,
        op 2* -> rand,
        op 3* -> key
    })
    vars P P' : Prin
    vars R R' : Rand
    vars K K' : Key
    eq ((P,R,K) = (P',R',K')) = (P = P' and R = R' and K = K') .
}

mod! BASIS-KNOWLEDGE principal-sort BasisKL {
    pr(TUPLE3(PRIN,RAND,BASIS) * {
        sort Tuple3 -> BasisKL,
        op 1* -> prin,
        op 2* -> rand,
        op 3* -> basis
    })
    vars P P' : Prin
    vars R R' : Rand
    vars B B' : Basis
    eq ((P,R,B) = (P',R',B')) = (P = P' and R = R' and B = B') .
}

mod! ACK-KNOWLEDGE principal-sort AckKL {
    pr(TUPLE3(PRIN,RAND,ACK) * {
        sort Tuple3 -> AckKL,
        op 1* -> prin,
        op 2* -> rand,
        op 3* -> ack
    })
    vars P P' : Prin
    vars R R' : Rand
    vars A A' : Ack
    eq ((P,R,A) = (P',R',A')) = (P = P' and R = R' and A = A') .
}

mod! SET(D :: TRIV) {
    [Elt.D < Set]
    op empty : -> Set {constr}
    op __ : Set Set -> Set {constr assoc comm id: empty}
    op _\in_ : Elt.D Set -> Bool
    var S : Set
    vars E E' : Elt.D
    eq E E = E .
    eq E \in empty = false .
    eq E \in (E' S) = (E = E') or (E \in S) .
}

mod! KEY-KNOWLEDGE-SET {
    pr(RAND + PRIN)
    pr(SET(KEY-KNOWLEDGE) * {sort Set -> KeyKLSet})
    [Key ErrKey < Key&Err]
    -- 
    op errK : -> ErrKey {constr}
    -- 
    vars KL KL' : KeyKL
    var KLS : KeyKLSet
    var P : Prin
    var R : Rand
    -- 
    eq (KL \in empty) = false .
    eq (KL \in (KL' KLS)) = (prin(KL) = prin(KL') and rand(KL) = rand(KL') and 
                             key(KL) = key(KL')) or (KL \in KLS) .
    -- 
    op hasKey : KeyKLSet Prin Rand -> Bool
    eq hasKey(empty,P,R) = false .
    eq hasKey(KL KLS,P,R) = (prin(KL) = P and rand(KL) = R) or hasKey(KLS,P,R) .
    -- 
    op key : KeyKLSet Prin Rand -> Key&Err
    eq key(empty,P,R) = errK .
    eq key(KL KLS,P,R) = (if (prin(KL) = P and rand(KL) = R) then key(KL) else key(KLS,P,R) fi) .
    -- lemmas
    op k-lm1 : KeyKLSet Prin Rand -> Bool
    eq k-lm1(KLS,P,R) = hasKey(KLS,P,R) implies not(key(KLS,P,R) = errK) .
}

mod! BASIS-KNOWLEDGE-SET {
    pr(RAND + PRIN)
    pr(SET(BASIS-KNOWLEDGE) * {sort Set -> BasisKLSet})
    [Basis ErrBasis < Basis&Err]
    -- 
    op errB : -> ErrBasis {constr}
    -- 
    vars KL KL' : BasisKL
    var KLS : BasisKLSet
    vars P P2 : Prin
    vars R R2 : Rand
    -- 
    eq (KL \in empty) = false .
    eq (KL \in (KL' KLS)) = (prin(KL) = prin(KL') and rand(KL) = rand(KL') and 
                             basis(KL) = basis(KL')) or (KL \in KLS) .
    -- 
    op hasBasis : BasisKLSet Prin Rand -> Bool
    eq hasBasis(empty,P,R) = false .
    eq hasBasis(KL KLS,P,R) = (prin(KL) = P and rand(KL) = R) or hasBasis(KLS,P,R) .
    -- 
    op basis : BasisKLSet Prin Rand -> Basis&Err
    eq basis(empty,P,R) = errB .
    eq basis(KL KLS,P,R) = (if (prin(KL) = P and rand(KL) = R) then basis(KL) else basis(KLS,P,R) fi) .
    -- lemmas
    op b-lm1 : BasisKLSet Prin Rand -> Bool
    eq b-lm1(KLS,P,R) = hasBasis(KLS,P,R) implies not(basis(KLS,P,R) = errB) .
    -- 
    op b-lm2 : BasisKLSet Prin Rand Prin Rand -> Bool
    eq b-lm2(KLS,P,R,P2,R2) = (P = P2 and R = R2) implies (hasBasis(KLS,P,R) = hasBasis(KLS,P2,R2)) .
}

mod! ACK-KNOWLEDGE-SET {
    pr(RAND + PRIN)
    pr(SET(ACK-KNOWLEDGE) * {sort Set -> AckKLSet})
    [Ack ErrAck < Ack&Err]
    -- 
    op errA : -> ErrAck {constr}
    -- 
    vars KL KL' : AckKL
    var KLS : AckKLSet
    var P : Prin
    var R : Rand
    -- 
    eq (KL \in empty) = false .
    eq (KL \in (KL' KLS)) = (prin(KL) = prin(KL') and rand(KL) = rand(KL') and 
                             ack(KL) = ack(KL')) or (KL \in KLS) .
    -- 
    op hasAck : AckKLSet Prin Rand -> Bool
    eq hasAck(empty,P,R) = false .
    eq hasAck(KL KLS,P,R) = (prin(KL) = P and rand(KL) = R) or hasAck(KLS,P,R) .
    -- 
    op ack : AckKLSet Prin Rand -> Ack&Err
    eq ack(empty,P,R) = errA .
    eq ack(KL KLS,P,R) = (if (prin(KL) = P and rand(KL) = R) then ack(KL) else ack(KLS,P,R) fi) .
    -- lemmas
    op a-lm1 : AckKLSet Prin Rand -> Bool
    eq a-lm1(KLS,P,R) = hasAck(KLS,P,R) implies not(ack(KLS,P,R) = errA) .
}

mod! Q-MESSAGE principal-sort QMsg {
    pr(PRIN + RAND + QUBIT)
    [QMsg]
    -- creator sender receiver
    op qm : Prin Prin Prin Rand Qubit -> QMsg {constr}
}

mod! MESSAGE principal-sort Msg {
    pr(PRIN + RAND + QUBIT + ACK)
    [Msg]
    -- creator sender receiver
    op m1 : Prin Prin Prin Rand Basis -> Msg {constr}
    op m2 : Prin Prin Prin Rand Ack -> Msg {constr}
}

mod! BAG(D :: TRIV) {
    [Elt.D < Bag]
    op void : -> Bag {constr}
    op _,_ : Bag Bag -> Bag {constr assoc comm id: void}
    op _\in_ : Elt.D Bag -> Bool
    var B : Bag
    vars E E' : Elt.D
    eq E \in void = false .
    eq E \in (E', B) = (E = E') or (E \in B) .
}

mod! NETWORK {
    pr(BAG(MESSAGE) * { sort Bag -> Network })
}

mod! CELL(E :: TRIV) {
    [Elt.E < Cell]
    op emp : -> Cell {constr}
    op isEmp : Cell -> Bool
    op hd : Cell -> Elt.E
    op tl : Cell -> Cell
    var E : Elt.E
    eq (emp = E) = false .
    eq isEmp(emp) = true .
    eq isEmp(E) = false .
    eq hd(E) = E .
    eq tl(E) = emp .
}

mod! BB84 {
    pr(NETWORK)
    pr(CELL(Q-MESSAGE) * { sort Cell -> QNetwork })
    pr(KEY-KNOWLEDGE-SET + BASIS-KNOWLEDGE-SET + ACK-KNOWLEDGE-SET)
    pr(SET(RAND) * { sort Set -> URand})
    [Sys]
    -- initial states
    op init : -> Sys {constr}
    -- transitions
    op sdqm : Sys Prin Prin Rand Key Basis          -> Sys {constr}
    op sdm1 : Sys Prin Prin Prin Rand Qubit Basis   -> Sys {constr}
    op sdm2 : Sys Prin Prin Prin Rand Basis Basis   -> Sys {constr}
    op cfm  : Sys Prin Prin Prin Rand Ack           -> Sys {constr}
    op fkqm : Sys Prin Prin Prin Rand Qubit Basis   -> Sys {constr}
    -- observation function
    op ur       : Sys -> URand
    op nw       : Sys -> Network
    op keys     : Sys -> KeyKLSet
    op bases    : Sys -> BasisKLSet
    op acks     : Sys -> AckKLSet
    op qnw      : Sys -> QNetwork
    -- 
    var S : Sys
    var M : Msg
    var R : Rand
    vars P Q P2 Q2 : Prin
    var K : Key
    vars B B' : Basis
    var KB : Qubit
    var A : Ack

    -- for initial states
    eq ur(init) = empty .
    eq nw(init) = void .
    eq keys(init) = empty .
    eq bases(init) = empty .
    eq acks(init) = empty .
    eq qnw(init) = emp .

    -- for sdqm
    op c-sdqm : Sys Prin Prin Rand Key Basis -> Bool
    eq c-sdqm(S,P,Q,R,K,B) = not(R \in ur(S)) and isEmp(qnw(S)) and 
                             not(hasKey(keys(S),P,R)) and not(hasBasis(bases(S),P,R)) .
    -- 
    ceq ur(sdqm(S,P,Q,R,K,B)) = R ur(S) if c-sdqm(S,P,Q,R,K,B) .
    ceq keys(sdqm(S,P,Q,R,K,B)) = (P,R,K) keys(S) if c-sdqm(S,P,Q,R,K,B) .
    ceq bases(sdqm(S,P,Q,R,K,B)) = (P,R,B) bases(S) if c-sdqm(S,P,Q,R,K,B) .
    ceq qnw(sdqm(S,P,Q,R,K,B)) = qm(P,P,Q,R,qubit(K,B)) if c-sdqm(S,P,Q,R,K,B) .
    eq nw(sdqm(S,P,Q,R,K,B)) = nw(S) .
    eq acks(sdqm(S,P,Q,R,K,B)) = acks(S) .
    ceq sdqm(S,P,Q,R,K,B) = S if not c-sdqm(S,P,Q,R,K,B) .
    
    -- for sdm1
    op c-sdm1 : Sys Prin Prin Prin Rand Qubit Basis -> Bool
    eq c-sdm1(S,P,P2,Q,R,KB,B) = not(isEmp(qnw(S))) and (hd(qnw(S)) = qm(P2,P,Q,R,KB)) and
                                 not(hasBasis(bases(S),Q,R)) .
    -- 
    eq ur(sdm1(S,P,P2,Q,R,KB,B)) = ur(S) .
    ceq keys(sdm1(S,P,P2,Q,R,KB,B)) = (if B = b(KB) then (Q,R,k(KB)) else (Q,R,measure(KB,B)) fi) keys(S) if c-sdm1(S,P,P2,Q,R,KB,B) .
    ceq bases(sdm1(S,P,P2,Q,R,KB,B)) = (Q,R,B) bases(S) if c-sdm1(S,P,P2,Q,R,KB,B) .
    ceq qnw(sdm1(S,P,P2,Q,R,KB,B)) = tl(qnw(S)) if c-sdm1(S,P,P2,Q,R,KB,B) .
    ceq nw(sdm1(S,P,P2,Q,R,KB,B)) = m1(Q,Q,P,R,B), nw(S) if c-sdm1(S,P,P2,Q,R,KB,B) .
    eq acks(sdm1(S,P,P2,Q,R,KB,B)) = acks(S) .
    ceq sdm1(S,P,P2,Q,R,KB,B) = S if not c-sdm1(S,P,P2,Q,R,KB,B) .

    -- for sdm2
    op c-sdm2 : Sys Prin Prin Prin Rand Basis Basis -> Bool
    eq c-sdm2(S,P,Q,Q2,R,B,B') = hasKey(keys(S),P,R) and (P,R,B) \in bases(S) and 
                                 m1(Q2,Q,P,R,B') \in nw(S) and
                                 not(hasAck(acks(S),P,R)) .
    -- 
    eq ur(sdm2(S,P,Q,Q2,R,B,B')) = ur(S) .
    eq keys(sdm2(S,P,Q,Q2,R,B,B')) = keys(S) .
    eq bases(sdm2(S,P,Q,Q2,R,B,B')) = bases(S) .
    eq qnw(sdm2(S,P,Q,Q2,R,B,B')) = qnw(S) .
    ceq nw(sdm2(S,P,Q,Q2,R,B,B')) = (if B = B' then m2(P,P,Q,R,ok) else m2(P,P,Q,R,notOk) fi), nw(S) if c-sdm2(S,P,Q,Q2,R,B,B') .
    ceq acks(sdm2(S,P,Q,Q2,R,B,B')) = (if B = B' then (P,R,ok) else (P,R,notOk) fi) acks(S) if c-sdm2(S,P,Q,Q2,R,B,B') .
    ceq sdm2(S,P,Q,Q2,R,B,B') = S if not c-sdm2(S,P,Q,Q2,R,B,B') .
    
    -- for cfm
    op c-cfm : Sys Prin Prin Prin Rand Ack -> Bool
    eq c-cfm(S,P,P2,Q,R,A) = m2(P2,P,Q,R,A) \in nw(S) and not(hasAck(acks(S),Q,R)) .
    -- 
    eq ur(cfm(S,P,P2,Q,R,A)) = ur(S) .
    eq keys(cfm(S,P,P2,Q,R,A)) = keys(S) .
    eq bases(cfm(S,P,P2,Q,R,A)) = bases(S) .
    eq qnw(cfm(S,P,P2,Q,R,A)) = qnw(S) .
    eq nw(cfm(S,P,P2,Q,R,A)) = nw(S) .
    ceq acks(cfm(S,P,P2,Q,R,A)) = (Q,R,A) acks(S) if c-cfm(S,P,P2,Q,R,A) .
    ceq cfm(S,P,P2,Q,R,A) = S if not c-cfm(S,P,P2,Q,R,A) .

    -- for fkqm
    op c-fkqm : Sys Prin Prin Prin Rand Qubit Basis -> Bool
    eq c-fkqm(S,P,P2,Q,R,KB,B) = not(isEmp(qnw(S))) and (hd(qnw(S)) = qm(P2,P,Q,R,KB)) and 
                                 not(hasBasis(bases(S),intruder,R)) .
    -- 
    eq ur(fkqm(S,P,P2,Q,R,KB,B)) = ur(S) .
    ceq keys(fkqm(S,P,P2,Q,R,KB,B)) = (if (b(KB) = B) then (intruder,R,k(KB)) else (intruder,R,measure(KB,B)) fi) keys(S) if c-fkqm(S,P,P2,Q,R,KB,B) .
    ceq bases(fkqm(S,P,P2,Q,R,KB,B)) = (intruder,R,B) bases(S) if c-fkqm(S,P,P2,Q,R,KB,B) .
    ceq qnw(fkqm(S,P,P2,Q,R,KB,B)) = (if (b(KB) = B) then qm(intruder,P,Q,R,qubit(k(KB),b(KB))) else qm(intruder,P,Q,R,qubit(measure(KB,B),B)) fi) if c-fkqm(S,P,P2,Q,R,KB,B) .
    eq nw(fkqm(S,P,P2,Q,R,KB,B)) = nw(S) .
    eq acks(fkqm(S,P,P2,Q,R,KB,B)) = acks(S) .
    ceq fkqm(S,P,P2,Q,R,KB,B) = S if not c-fkqm(S,P,P2,Q,R,KB,B) .
}

mod INV {
    pr(BB84)
    -- 
    var S : Sys
    var R : Rand
    vars P Q : Prin
    -- 
    op isComplete : Sys Prin Prin Rand -> Bool
    eq isComplete(S,P,Q,R) = hasKey(keys(S),P,R) and hasBasis(bases(S),P,R) and hasAck(acks(S),P,R) and
                             hasKey(keys(S),Q,R) and hasBasis(bases(S),Q,R) and hasAck(acks(S),Q,R) .
    op evePresent : Sys Rand -> Bool
    eq evePresent(S,R) = hasKey(keys(S),intruder,R) and hasBasis(bases(S),intruder,R) .
    -- 
    op sameBasis : Sys Prin Prin Rand -> Bool
    eq sameBasis(S,P,Q,R) = (basis(bases(S),P,R) = basis(bases(S),Q,R)) .
    -- 
    op sameKey : Sys Prin Prin Rand -> Bool
    eq sameKey(S,P,Q,R) = (key(keys(S),P,R) = key(keys(S),Q,R)) .
    -- 
    op inv1 : Sys Prin Prin Rand -> Bool
    eq inv1(S,P,Q,R) = (isComplete(S,P,Q,R) and sameBasis(S,P,Q,R) and not(sameKey(S,P,Q,R)))
                       implies evePresent(S,R) .
    -- 
    op inv2 : Sys Prin Prin Rand -> Bool
    eq inv2(S,P,Q,R) = (isComplete(S,P,Q,R) and sameBasis(S,P,Q,R) and not(evePresent(S,R)))
                       implies sameKey(S,P,Q,R) .

    -- 
    op inv3 : Sys Prin Rand -> Bool
    eq inv3(S,P,R) = hasAck(acks(S),P,R) implies (hasKey(keys(S),P,R) and hasBasis(bases(S),P,R)) .
}